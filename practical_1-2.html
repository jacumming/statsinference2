<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Practical 1-2: Sampling and Simulation</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.5.1/jquery-3.5.1.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Statistical Concepts 2</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Term 1
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="practical_1-1.html">Practical 1 - Introduction to R</a>
    </li>
    <li>
      <a href="practical_1-2.html">Practical 2 - Sampling and Simulation</a>
    </li>
    <li>
      <a href="practical_1-3.html">Practical 3 - Likelihood Inference</a>
    </li>
    <li>
      <a href="practical_1-4.html">Practical 4 - Bayesian Inference</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Term 2
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="practical_2-1.html">Practical 1</a>
    </li>
    <li>
      <a href="practical_2-2.html">Practical 2</a>
    </li>
    <li>
      <a href="practical_2-3.html">Practical 3</a>
    </li>
    <li>
      <a href="practical_2-4.html">Practical 4</a>
    </li>
    <li>
      <a href="practical_2-5.html">Practical 5</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="install.html">
    <span class="fa fa-download"></span>
     
    Install
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-question-circle"></span>
     
    R Help
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="r_1_gettingstarted.html">1. Getting Started</a>
    </li>
    <li>
      <a href="r_2_variables.html">2. Variables</a>
    </li>
    <li>
      <a href="r_3_functions.html">3. Functions</a>
    </li>
    <li>
      <a href="r_4_vectors.html">4. Vectors</a>
    </li>
    <li>
      <a href="r_5_basicstats.html">5. Standard statistical functions</a>
    </li>
    <li>
      <a href="r_6_matrices.html">6. Matrices and data frames</a>
    </li>
    <li>
      <a href="r_7_plots.html">7. Plots</a>
    </li>
    <li>
      <a href="r_8_advplots.html">8. Advanced Plots</a>
    </li>
    <li>
      <a href="r_9_programming.html">9. Programming</a>
    </li>
    <li>
      <a href="r_10_statsmethods.html">10. Statistical methods</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="rstudio-ide.pdf">Cheatsheet: RStudio infterface</a>
    </li>
    <li>
      <a href="base-r.pdf">Cheatsheet: Base R</a>
    </li>
  </ul>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Practical 1-2: Sampling and Simulation</h1>

</div>


<!-- In this session we perform simple simulation exercises in order to investigate the properties of the sample mean introduced in the lectures. -->
<!-- Today we will learn R techniques beyond those seen in the first year (if you were a Stats student), including the use of loops and writing your own functions.  -->
<!--  *  [Download the R Script](scripts/practical_1-2.R) - Right click, and Save As -->
<!-- ```{block2, type='goals'} -->
<!--  *  You will need the following skills from previous practicals: -->
<!--     *   Basic R skills with arithmetic, functions, etc -->
<!--     *   Manipulating and creating vectors: `c`, `seq`,  -->
<!--     *   Calculating data summaries: `mean`, `sd`, `var`, `min`, `max` -->
<!--     *   Plotting a scatterplot with `plot`, and a histogram with `hist` -->
<!--  *  New R techniques: -->
<!--     *   Sampling with and without replacement from a vector using `sample` -->
<!--     *   Creating new functions with `function` -->
<!--     *   Creating traditional `for` loops to iterate calculations -->
<!--     *   Using `sapply` to repeat calculations over a vector of values -->
<!--     *   Using `par(mfrow=c(a,b))` to setup a grid of plots -->
<!--     *   Adding straight lines to plots with `abline` -->
<!-- ```  -->
<!-- # Sampling without replacement {.first} -->
<!-- We'll be using the `hospital` data set from the `durham` library in our sampling experiments. So, before we begin you'll need to load the data: -->
<!-- ```{block2, type='question'} -->
<!--  * Refer to [the worksheet from last time](practical_1-1.html#DurhamLibrary) and either: -->
<!--     * Load the `durham` library and the `hospital` data set. -->
<!--     * If you have problems loading the library, use the code on [this page](data_hospital.html) to create the data set without the library -->
<!--  * Create a new vector called `disch` (or similar) containing the data for the number of discharges in the `hospital` data. -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide'} -->
<!-- library(durham) -->
<!-- data(hospital) -->
<!-- disch <- hospital$discharges -->
<!-- ``` -->
<!-- Recall that our general approach to sampling is to sample without replacement, so we don't repeatedly observe the same individual from the population. We can use `R`'s `sample` function to take random samples from a specified population vector, and we can do so either with or without replacement. -->
<!-- ```{block2, type='technique'} -->
<!-- The `sample` function allows us to take a sample of a specified size from a vector of values which is treated as the population.  -->
<!-- If we have a population vector `pop` and we want to take a sample of size `n` without replacement, then we use the following command: -->
<!-- `sample(pop, n)` -->
<!-- If we want to sample _with_ replacement, then we can add the additional optional argument `replace=TRUE`. -->
<!-- Finally, the default is for all of the elements of the population to have equal probability. This can be changed to specified probability weights using the `prob` argument, but we won't be looking into that any further. See the help file (by running `?sample`) for more details on the `sample` function. -->
<!-- ``` -->
<!-- ```{block2, type='question'} -->
<!--  * Draw a sample (without replacement) of size $n=4$ from the discharges data. -->
<!--  * Draw another sample of size $n=4$  - do you get the same sample values? -->
<!--  * Let's experiment with changing the sample size. For sample sizes $n_1=4$, $n_2=16$, and $n_3=64$ generate a random sample, and compute its sample `mean`. Do this in three lines, one for each sample size. -->
<!--  * Compare the three means - what would you expect to see? -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide'} -->
<!-- sample(disch, 4) -->
<!-- sample(disch, 4) ## unsurprisingly different -->
<!-- mean(sample(disch,4)) -->
<!-- mean(sample(disch,16)) -->
<!-- mean(sample(disch,64)) -->
<!-- ## potentially quite different values. We would expect the mean of these means to be mu, -->
<!-- ## so the values should be centred about mu but its difficult to say more with only a few points -->
<!-- ``` -->
<!-- We will be performing a repeated sampling experiment where we repeat the sampling many times to generate different samples each time. Then we can use the many samples to produce many different sample means, which we can explore to check their behaviour against what we would expect from the theory seen in lectures. -->
<!-- # Functions and loops  -->
<!-- To simplify the repeated sampling calculation, we will use a loop to repeat the calculations and we will write our own function to take care of the calculations we wish to perform during each iteration. -->
<!-- ## Functions  -->
<!-- As with other programming languages (such as Python), we can combine multiple commands in `R` into our own custom functions that perform more complicated tasks or calculations. Throughout the year, we will be writing our own functions to solve specific problems and today we will learn the basic syntax of how to create a function. -->
<!-- ```{block2, type='technique'} -->
<!-- When creating a new function, it needs to have a name, probably at least one argument (although it doesn’t have to), and a body of code that does something. At the end it usually should (although doesn’t have to) return a value or object out of the function.  -->
<!-- The general syntax for writing your own function is -->
<!-- ``` -->
<!-- ```{r, eval=FALSE} -->
<!-- name.of.function <- function(arg1, arg2, arg3=2) { -->
<!--   # function code to do some useful stuff -->
<!--   return(something) # return value  -->
<!-- } -->
<!-- ``` -->
<!-- ```{block2, type='technique'} -->
<!--  + **`name.of.function`**: is the function’s name. This can be any valid variable name, but you should avoid using names that are used elsewhere in R, such as `mean`, `function`, `plot`, etc. -->
<!--  + **`arg1`, `arg2`, `arg3`**: these are the arguments of the function. You can write a function with any number of arguments, or none at all. These can be any _R_ object: numbers, strings, arrays, data frames, or even other functions. Essentially, this is the list of everything that is needed for the `name.of.function` function to run. -->
<!-- Some arguments have default values specified, such as `arg3` in our example, which is set to `2` unless otherwise specified. Arguments without a default must have a value supplied for the function to run. You do not need to provide a value for those arguments with a default as they are considered as optional, and when omitted the function will simply use the default value in its definition. -->
<!--  + **Function body**: The function code between the within the `{}` brackets is run every time the function is called. Note that unlike Python where the code _inside_ the function is _indented_, with `R` the code inside the function must be enclosed in curly braces `{}`. This code might be very long or very short. Ideally functions are short and do just one thing – problems are rarely too small to benefit from some abstraction. Sometimes a large function is unavoidable, but usually these can be in turn constructed from a number of small functions.  -->
<!--  + **Return value**: The last line of the code is the value that will be returned by the function.  It is not necessary that a function return anything, for example a function that makes a plot might not return anything (and so either state `return()` or omitting the `return` statement entirely), whereas a function that does a mathematical operation might return a number, or a vector. -->
<!-- ``` -->
<!-- For example, we can write a function to compute the sum of squares of two numbers as -->
<!-- ```{r} -->
<!-- sum.of.squares <- function(x,y) { -->
<!--   return(x^2 + y^2) -->
<!-- } -->
<!-- ``` -->
<!-- and we can then evaluate -->
<!-- ```{r} -->
<!-- sum.of.squares(3,4) -->
<!-- ``` -->
<!-- ```{block2, type='question'} -->
<!--   * Create a function called `MyFun` that takes a single argument `x` and returns the value of $1+x+0.1x^2$. -->
<!--   * Use your function to evaluate $1+x+0.1x^2$ when $x=0$. -->
<!--   * Create a vector of the integers from $0$ to $100$, and evaluate $1+x+0.1x^2$ for $x=0,\dots,100$. You should do this in one line without resorting to any loops or iterative methods, or temporary variables. _Hint:_ See the previous practical for how to create vectors of integer sequences, and how to do arithmetic with vectors. -->
<!--   * Create another function called `MyFunPlotter`, which takes a single argument `x`, and which draws a scatter`plot` of the points `(x, MyFun(x))`. Evalate your function for $x=0,\dots,100$. _Hint:_ See the previous practical for how to draw scatterplots, and use your function from the previous part of the question. -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide'} -->
<!-- MyFun <- function(x){ -->
<!--   return(1+x+0.1*x^2) -->
<!-- } -->
<!-- MyFun(0) -->
<!-- MyFun(0:100) -->
<!-- MyFunPlotter <- function(x){ -->
<!--   plot(x=x,y=MyFun(x)) -->
<!-- } -->
<!-- #MyFunPlotter(0:100) -->
<!-- ``` -->
<!-- ## Simple Loops -->
<!-- A "loop"" is a way to repeat a sequence of instructions under certain conditions. They allow you to automate parts of your code that are in need of repetition. We will look at two ways of creating loops in our code:  -->
<!--    * Traditional loops which execute for a prescribed number of times, as controlled by a counter or an index, incremented at each iteration cycle are represented as `for` loops in _R_. You will probably have seen these before with Python. -->
<!--    * Loops that take a function and apply that function to every element of a vector (or other array) are represented by the various `apply` functions in _R_. -->
<!-- ```{block2, type='technique'} -->
<!-- In _R_ a `for` loop takes the following general form: -->
<!-- ``` -->
<!-- ```{r,eval=FALSE} -->
<!-- for (variable in sequence) {  -->
<!--   ## code to repeat goes here -->
<!-- } -->
<!-- ``` -->
<!-- ```{block2, type='technique'} -->
<!-- where `variable` is a name given to the iteration variable and which takes each possible value in the vector `sequence` at each pass through the loop. -->
<!-- ``` -->
<!-- Here is a quick trivial example, printing the square root of the integers one to ten: -->
<!-- ```{r, eval=FALSE} -->
<!-- for (x in 1:10) { -->
<!--   print(sqrt(x)) -->
<!-- } -->
<!-- ``` -->
<!-- ```{block2, type='question'} -->
<!--    * Sometimes big loops aren't necessary! Write a single line of code that computes the square root of the integers $1$ to $10$ without using `for`.  -->
<!--    * Use a `for` loop to: -->
<!--       * Print the values of the integers $1$ to $5$. -->
<!--       * Print the squares of the integers from $10$ to $3$. -->
<!--       * Print your first name 10 times. -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide'} -->
<!-- sqrt(1:10) ## use a vector instead -->
<!-- for(i in 1:5){ -->
<!--   print(i) -->
<!-- } -->
<!-- for(i in 10:3){ -->
<!--   print(i^2) -->
<!-- } -->
<!-- for(i in 1:10){ -->
<!--   print("My Name") -->
<!-- } -->
<!-- ``` -->
<!-- While `for` loops are helpful when we need to explictly repeat a block of code, sometimes we just want to apply the same function (or calculations) to all of the elements of a vector. We can use `for` to do this, but _R_ provides a function which does exactly that - `sapply`.  -->
<!-- ```{block2, type='technique'} -->
<!-- `sapply` applies a specified function to every element of a vector and returns a vector formed from the results. -->
<!-- `sapply(X, FUN)` -->
<!-- applies the function `FUN` to every element of the vector `X` it then returns a vector containing the values of `FUN(X[1])`, `FUN(X[2])`, and so on. So, to replicate the square-root example above using `sapply`, we would write -->
<!-- `sapply(1:10, FUN=sqrt)` -->
<!-- or alternatively -->
<!-- `sapply(1:10, FUN=function(i){sqrt(i)})` -->
<!-- which applies the square root function to each of the integers 1 to 10. Unlike a loop, `sapply` automatically returns its results as a vector without us having to write code for that (our `for` loop above only printed the values).  -->
<!-- There are other variations of `apply` which work with matrices and other data structures, and we will see those later. -->
<!-- ``` -->
<!-- If we combine this technique of looping with the ability to write our own functions, then we have a very flexible way of re-writing a standard loop in a vectorised way. In general, using the `sapply` function is to be preferred to a `for` loop particularly when we want to keep the results of the calculations from each iteration. However, `for` loops are still useful and more natural in certain cases (where we do not want the output values, or where each iteration has a dependency on the calculations at the previous step). -->
<!-- ```{block2, type='question'} -->
<!--    * Use `sapply` to re-write your for-loops. You should write your answers in one line of code for each part: -->
<!--       * Return the values of the integers $1$ to $5$. -->
<!--       * Return the squares of the integers from $10$ to $3$. -->
<!--       * Return a vector of your first name 10 times. -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide'} -->
<!-- sapply(1:5, FUN=function(i) { i }) -->
<!-- sapply(10:3, FUN=function(i) { i^2 }) -->
<!-- sapply(1:10, FUN=function(i) { 'My Name' }) -->
<!-- ``` -->
<!-- # The Sampling Experiment -->
<!-- ```{block2, type='question'} -->
<!--    * Make a vector of the means of 30 different samples of size 4 from the hospital discharges vector using a combination of `sapply` and the functions `sample` and `mean`. -->
<!--    * Create a new function with argument `n` that returns a vector of the means of 1000 samples, each of size `n`, from the discharges data.  -->
<!--    _Hint:_ This is a one line function that places a version of the command used in the previous question within the function. -->
<!--    * Using your new function, create three vectors containing the means for 1000 samples of sizes $n_1=4$, $n_2=16$ and $n_3=64$ from the discharges data (giving each a name). -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide'} -->
<!-- sapply(1:30, FUN=function(i) {  mean(sample(disch, 4)) } ) -->
<!-- dischSample <- function(n){ -->
<!--   return(sapply(1:1000, FUN=function(i) {  mean(sample(disch, n)) } )) -->
<!-- } -->
<!-- means4 <- dischSample(4) -->
<!-- means16 <- dischSample(16) -->
<!-- means64 <- dischSample(64) -->
<!-- ``` -->
<!-- We now have samples of size 1000 from each of three sampling distributions of $\bar{X}$, for when $n=4$, $n=16$, $n=64$. As our samples of $\bar{X}$ values are quite large in size, we might expect that each of these distributions is quite similar to the distribution of the underlying theoretical population of sample means. -->
<!-- ```{block2, type='question'} -->
<!--    * Find the mean and standard deviation for each collection of sample means. Do the results agree with what you would expect? -->
<!--    * Draw a `boxplot` comparing each of the three samples on the same scale. (_Hint_: see the previous practical for how to draw a boxplot.) -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide', fig.show='hide'} -->
<!-- mean(means4) -->
<!-- sd(means4) -->
<!-- mean(means16) -->
<!-- sd(means16) -->
<!-- mean(means64) -->
<!-- sd(means64) -->
<!-- boxplot(means4, means16, means64) -->
<!-- ``` -->
<!-- ```{block2, type='technique'} -->
<!-- _R_ makes it easy to combine multiple plots into one overall graph, using either the `par` or `layout` functions. -->
<!-- With the `par` function, we specify the argument `mfrow=c(nr, nc)` to split the plot window into a grid of nr x nc plots that are filled in by row. For example, to divide the plot window into a 2x2 grid we call -->
<!-- `par(mfrow=c(2,2))` -->
<!-- This has no immediate effect, but the next four plots drawn (using `plot`, `hist`, `boxplot`, etc) will be drawn in the 2x2 grid. -->
<!-- To revert to a single plot layout, we ask for a 1x1 grid via `par(mfrow=c(1,1))`. -->
<!-- ``` -->
<!-- ```{block2, type='question'} -->
<!--    * Use the `par` function with the `mfrow` argument to configure to plot window for a column of three vertical plots. _Note:_ this function will have no effect until you start drawing new plots. -->
<!--    * Plot the samples of $\bar{X}$ as separate histograms, one on top of the other. Make sure the horizontal axes are the same (_Hint:_ use the `xlim` argument to specify the horizontal axis limits, and `range` will determine the min and max of a vector). -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide', fig.show='hide'} -->
<!-- par(mfrow=c(3,1)) -->
<!-- hist(means4, xlim=range(means4)) -->
<!-- hist(means16, xlim=range(means4)) -->
<!-- hist(means64, xlim=range(means4)) -->
<!-- ``` -->
<!-- ```{block2, type='technique'} -->
<!-- It is often useful to add simple straight lines to lines to plots, which can be achieved using the `abline` function. `abline` can be used in three different ways: -->
<!--  + Draw a horizontal line: pass a value to the `h` argument, `abline(h=3)` draws a horizontal line at $y=3$ -->
<!--  + Draw a vertical line: pass a value to the `v` argument, `abline(v=5)` draws a vertical line at $x=5$ -->
<!--  + Draw a line with given intercept and slope: pass value to the `a` and `b` arguments representing the intercept and slope respectively; `abline(a=1,b=2)` draws the line at $y=1+2x$ -->
<!-- `abline` can be customised using any of the usual colour and line modifications using colour [(`col`)](r_8_advplots.html#col), line types and widths [(`lty`, and `lwd`)](r_8_advplots.html#lwd). -->
<!-- ``` -->
<!-- ```{block2, type='question'} -->
<!--    * Redraw your histograms, this time adding a vertical line showing the population mean. -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide', fig.show='hide'} -->
<!-- par(mfrow=c(3,1)) -->
<!-- hist(means4, xlim=range(means4)) -->
<!-- abline(v=mean(disch),col='red') -->
<!-- hist(means16, xlim=range(means4)) -->
<!-- abline(v=mean(disch),col='red') -->
<!-- hist(means64, xlim=range(means4)) -->
<!-- abline(v=mean(disch),col='red') -->
<!-- ``` -->
<!-- According to theory seen in lectures, the sample mean is an unbiased estimator of the population mean, $\mu$, and has variance denoted $\sigma_{\bar{X}}$. For Normal data or large sample sizes, the sampling distribution is either exactly or approximately Normal with the above mean and variance. -->
<!-- ```{block2, type='question'} -->
<!--    * What do you observe about the three distributions? Does the picture correspond to the theory? -->
<!--    * What do you notice about the mean and standard deviation of your samples relative to the population for the three different sample sizes. -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide', fig.show='hide'} -->
<!-- ## distributions are all centred about mu (as they should be since Xbar is unbiased) -->
<!-- ## spread decreases with sample size (due primarily to the 1/n term in the variance of Xbar) -->
<!-- ## the distribution looks "more Normal" as n gets bigger (central limit theorem) -->
<!-- ``` -->
<!-- # The variance of the sample mean -->
<!-- We can use `R` to investigate the properties of the distribution of the sample mean more closely. The theory tells us that the variance of the sample mean, $\bar{X}$, for a sample of size $n$ from a _finite_ population of size $N$ is given by: -->
<!-- $$ -->
<!-- \text{Var}[\bar{X}] = \sigma^2_{\bar{X}} = \left(\frac{N-n}{N-1}\right)\frac{\sigma^2}{n}, -->
<!-- $$  -->
<!-- where $\sigma^2$ is the population variance of the original data, $X_i$. An unbiased estimator of this standard error is the estimated standard error, given by -->
<!-- $$ -->
<!-- S^2_{\bar{X}} = \left(1-\frac{n}{N}\right)\frac{s^2}{n}, -->
<!-- $$ -->
<!-- where $s^2$ is the sample variance. -->
<!-- ```{block2, type='question'} -->
<!--    * Calculate the true variance of the sample mean, $\sigma^2_{\bar{X}}$ for the samples of size 4, 16 and 64. -->
<!--    * Write a new function with argument `n` that returns a vector of 1000 realisations of $S^2_{\bar{X}}$ for samples of `n` from the discharges data.  -->
<!--    * Evaluate your function for $n=4$, $n=16$, and $n=64$ and store the result to three variables. -->
<!--    * Display each of these three samples as histograms, one on top of the other in the same plot. Make sure the horizontal axes are the same. -->
<!--    * Draw a vertical line on each one showing the location of the true variance of the sample mean in each case. -->
<!--    * Is the result of this experiment consistent with the theory? Why? -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results="hide", fig.show="hide"} -->
<!-- ## Careful with this step, as using `var` on the discharges vector uses the sample variance formula which  -->
<!-- ## assumes the sample mean is not mu and which divides by (c-1). We need the population variance as  -->
<!-- ## mean(disch)=mu since this is our population, and we want to divide by N. So either we need to correct the -->
<!-- ## output from var or compute directly.  -->
<!-- N <- length(disch) -->
<!-- sigma2 <- sum((disch-mean(disch))^2)/N -->
<!-- ## or -->
<!-- sigma2 <- (N-1)/N * var(disch) -->
<!-- ## compute sigma_xbar for n=4,16,64 - we should probably do this with a function! -->
<!-- trueV4 <- (N-4)/(N-1) * sigma2/4 -->
<!-- trueV16 <- (N-16)/(N-1) * sigma2/16 -->
<!-- trueV64 <- (N-64)/(N-1) * sigma2/64 -->
<!-- ## easiest to do this with a new function to compute S^2_Xbar for a given sample -->
<!-- S2Xbar <- function(x){ -->
<!--   n <- length(x) -->
<!--   return( (1-n/N)*var(x)/n) -->
<!-- } -->
<!-- ## then just swap `mean` for `S2Xbar` from our previous sampling function -->
<!-- dischVariances <- function(n){ -->
<!--   return(sapply(1:1000, FUN=function(i) {  S2Xbar(sample(disch, n)) } )) -->
<!-- } -->
<!-- vars4 <- dischVariances(4) -->
<!-- vars16 <- dischVariances(16) -->
<!-- vars64 <- dischVariances(64) -->
<!-- ``` -->
<!-- ```{r, echo=FALSE, results='hide', fig.show='hide'} -->
<!-- par(mfrow=c(3,1)) -->
<!-- hist(vars4, xlim=range(vars4)) -->
<!-- abline(v=trueV4,col='red') -->
<!-- hist(vars16, xlim=range(vars4)) -->
<!-- abline(v=trueV16,col='red') -->
<!-- hist(vars64, xlim=range(vars4)) -->
<!-- abline(v=trueV64,col='red') -->
<!-- ``` -->



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
